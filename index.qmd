---
title: "MPA Europe map platform"
format: 
  html:
    page-layout: custom
    header-includes: |
      <link rel="preconnect" href="https://fonts.googleapis.com">
      <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
      <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;500;600;700&display=swap" rel="stylesheet">
      <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200" />
      <style> @import url('https://fonts.googleapis.com/css2?family=Montserrat:wght@400;500;600;700&display=swap'); #title-block-header { display: none;} #quarto-content>* {padding-top: 0px;} </style>
mainfont: Montserrat
server: shiny
---

<!-- Add the top grid (map on the left, tabs on the right) --->

::: {.grid .column-screen .gridalt}

::: {.g-col-md-8 .g-col-12}
```{r echo=FALSE, message=FALSE, warning=FALSE}
# Load other packages that will be used
library(shiny)
library(plotly)
library(leaflet)
library(leaflet.extras)
library(leaflet.extras2)
library(leaflet.providers)

includeCSS("styles.css")
includeScript("addons.js")
# 
shiny_busy <- function() {
  # use &nbsp; for some alignment, if needed
  HTML(paste0(
    '<div class = "busyDiv" data-display-if="',
    '$(&#39;html&#39;).attr(&#39;class&#39;)==&#39;shiny-busy&#39;',
    '">',"Loading/processing data...",
    '<i class="fa fa-spinner fa-pulse fa-fw" style="color:#1a759f"></i>',
    '</div>'
  ))
}
```


```{r echo=FALSE, message=FALSE, warning=FALSE}
#| out-width: 100%
# Create a div to show messages if busy
shiny_busy()

# Create a sample graph div with a close button
graph_div <- htmltools::tags$div(
  id = "graphDiv",
  class = "graphDiv",
  htmltools::tags$button(
    onclick = "hideGraphDiv()",
    class = "graphDivButton",
    htmltools::tags$span(class="material-symbols-outlined", "close")),
    htmltools::tags$div(
      style = "width: 200px; height: 300px;",
      htmltools::tags$div(
        htmlOutput("contextMapText"),
        plotOutput("contextMap"))
      )
  )

check_div <- htmltools::tags$div(
  id = "checkDiv",
  class = "checkDiv",
  conditionalPanel("input.scenarioSelect != 'Current'",
                 tags$div(
                     id = "sideside_box",
                     class = "sideside_class",
                     checkboxInput(
                       inputId = "sideSelect",
                       label = "Split map viewer"
      )))
)

side_div <- htmltools::tags$div(
  id = "sideDiv",
  class = "sideDiv",
  conditionalPanel("input.sideSelect == true",
                 tags$div(
                     id = "sidetext_box",
                     class = "sidetext_class",
                     "Current"))
)

side_div_right <- htmltools::tags$div(
  id = "sideDivRight",
  class = "sideDivRight",
  conditionalPanel("input.sideSelect == true",
                 tags$div(
                     id = "sidetext_box_r",
                     class = "sidetext_class_r",
                     "Future"))
)
  
# Combine Leaflet map and graph div
combined <- htmltools::tags$div(
  style = "position: relative;",
  htmltools::browsable(leafletOutput("mainMap", height = 600)),
  graph_div,
  check_div,
  side_div, side_div_right
)

combined
```
:::

::: {.g-col-md-4 .g-col-12 .colordiv}
::: {.panel-tabset}

## SPECIES

::: {.tabdiv}

```{r}
# Load/set options ----
# Load group options
group_options <- c("All", "Others")

# Set model option
model_options <- c("BRT" = "brt", "Random Forest" = "rf_classification_ds", 
                  "MAXENT" = "maxnet", "XGBoost" = "xgboost",
                    "Elasticnet" = "elasticnet", "Ensemble" = "ensemble")
scenario_options <- c("Current", "SSP1" = "ssp126", "SSP2" = "ssp245",
                      "SSP3" = "ssp370", "SSP4" = "ssp460", "SSP5" = "ssp585")
period_options <- c(2050, 2100)

# Add selectors ----
# Group selector
selectInput(
   inputId = "groupSelect",
   label = "Select group", 
   choices = group_options
)

# Species selector
tags$div(
  id = 'italic_div',
  class = 'itdiv_class',
  selectizeInput(
    inputId = "speciesSelect",
    label = "Search species",
    choices = c("Select one" = ""),
    multiple = FALSE
  )
)

# Add contextual information ----
tags$div(
  id = "species_title",
  class = "rtitle_class",
  textOutput("selectedSpecies")
)

tags$div(
  id = "context_info",
  class = "context_info",
  htmlOutput("contextSpecies")
)
```

<div class="bottom-container"> 
::: {.grid .gridaltsm}

::: {.g-col-5}
```{r}
tags$div(
  id = "scenario_box",
  class = "scenario_class",
selectInput(
        inputId = "modelSelect",
        label = "Model",
        choices = model_options
      ))
```
:::

::: {.g-col-4}
```{r}
conditionalPanel("input.speciesSelect != ''",
                 tags$div(
                    id = "scenario_box",
                    class = "scenario_class",
                     selectInput(
                       inputId = "scenarioSelect",
                       label = "Scenario",
                       choices = scenario_options
                     )))
```

:::

::: {.g-col-3}
```{r}
conditionalPanel("input.scenarioSelect != 'Current'",
                 tags$div(
                     id = "scenario_box",
                     class = "scenario_class",
                     selectInput(
                       inputId = "periodSelect",
                       label = "Period",
                       choices = period_options
      )))
```

:::

:::
</div>

<div class="context-icons">

<div class="context-icons-box" onclick="location.href='https://obis.org';">{{< fa download >}} DOWNLOAD THE FILE</div>

<div class="context-icons-box" onclick="location.href='https://obis.org';">{{< fa brands github >}} ACCESS THE CODE</div>

<div class="context-icons-box" onclick="location.href='https://obis.org';">{{< fa play >}} RUN THE MODEL</div>

</div>


:::

## THERMAL RANGE

::: {.tabdiv}

```{r}
# Load/set options ----

# Add selectors ----
# Group selector
selectInput(
   inputId = "groupSelectThermal",
   label = "Select group", 
   choices = group_options
)

# Species selector
tags$div(
  id = 'italic_div_thermal',
  class = 'itdiv_class',
  selectInput(
    inputId = "speciesSelectThermal",
    label = "Search species",
    choices = c("Test", "Test B")
  )
)

# Add contextual information ----
tags$div(
  id = "thermal_species_title",
  class = "rtitle_class",
  textOutput("selectedSpeciesThermal")
)

tags$div(
  id = "context_info_thermal",
  class = "context_info",
  textOutput("contextSpeciesThermal")
)
```

<div class="bottom-container"> 
::: {.grid .gridaltsm}

::: {.g-col-5}
```{r}
tags$div(
  id = "scenario_box_thermal",
  class = "scenario_class",
selectInput(
        inputId = "modelSelectThermal",
        label = "Model",
        choices = model_options
      ))
```
:::

::: {.g-col-4}
```{r}
tags$div(
  id = "scenario_box_thermal",
  class = "scenario_class",
      selectInput(
        inputId = "scenarioSelectThermal",
        label = "Scenario",
        choices = scenario_options
      ))
```

:::

::: {.g-col-3}
```{r}
tags$div(
  id = "scenario_box_thermal",
  class = "scenario_class",
      selectInput(
        inputId = "periodSelectThermal",
        label = "Period",
        choices = period_options
      ))
```

:::

:::
</div>

<div class="context-icons">

<div class="context-icons-box" onclick="location.href='https://obis.org';">{{< fa download >}} DOWNLOAD THE FILE</div>

<div class="context-icons-box" onclick="location.href='https://obis.org';">{{< fa brands github >}} ACCESS THE CODE</div>

<div class="context-icons-box" onclick="location.href='https://obis.org';">{{< fa play >}} RUN THE MODEL</div>

</div>

:::


## HABITAT

::: {.tabdiv}

```{r}
# Load/set options ----
# Load habitat options
hab_options <- c("All", "Algae")

# Add selectors ----
# Filter selector
selectInput(
   inputId = "habitatSelect",
   label = "Filter by type", 
   choices = hab_options
)

# Add contextual information ----
tags$div(
  id = "habitat_title",
  class = "rtitle_class",
  textOutput("selectedHabitat")
)

tags$div(
  id = "context_info_hab",
  class = "context_info",
  textOutput("contextHabitat")
)
```

<div class="bottom-container"> 
::: {.grid .gridaltsm}

::: {.g-col-5}
```{r}
tags$div(
  id = "scenario_box_habitat",
  class = "scenario_class",
selectInput(
        inputId = "modelSelectHabitat",
        label = "Model",
        choices = model_options
      ))
```
:::

::: {.g-col-4}
```{r}
tags$div(
  id = "scenario_box_habitat",
  class = "scenario_class",
      selectInput(
        inputId = "scenarioSelectHabitat",
        label = "Scenario",
        choices = scenario_options
      ))
```

:::

::: {.g-col-3}
```{r}
tags$div(
  id = "scenario_box_thermal",
  class = "scenario_class",
      selectInput(
        inputId = "periodSelectHabitat",
        label = "Period",
        choices = period_options
      ))
```

:::

:::
</div>

<div class="context-icons">

<div class="context-icons-box" onclick="location.href='https://obis.org';">{{< fa download >}} DOWNLOAD THE FILE</div>

<div class="context-icons-box" onclick="location.href='https://obis.org';">{{< fa brands github >}} ACCESS THE CODE</div>

<div class="context-icons-box" onclick="location.href='https://obis.org';">{{< fa play >}} RUN THE MODEL</div>

</div>

:::


## DIVERSITY

::: {.tabdiv}

```{r}
# Load/set options ----
# Load metrics options
metrics_options <- c("Richness", "E50")

# Add selectors ----
# Filter selector
selectInput(
   inputId = "habitatSelect",
   label = "Select metric", 
   choices = metrics_options
)

# Add contextual information ----
tags$div(
  id = "diversity_title",
  class = "rtitle_class",
  textOutput("selectedMetric")
)

tags$div(
  id = "context_info_div",
  class = "context_info",
  textOutput("contextMetric")
)
```

<div class="bottom-container"> 
::: {.grid .gridaltsm}

::: {.g-col-5}
```{r}
tags$div(
  id = "scenario_box_diversity",
  class = "scenario_class",
selectInput(
        inputId = "modelSelectDiversity",
        label = "Model",
        choices = model_options
      ))
```
:::

::: {.g-col-4}
```{r}
tags$div(
  id = "scenario_box_diversity",
  class = "scenario_class",
      selectInput(
        inputId = "scenarioSelectDiversity",
        label = "Scenario",
        choices = scenario_options
      ))
```

:::

::: {.g-col-3}
```{r}
tags$div(
  id = "scenario_box_diversity",
  class = "scenario_class",
      selectInput(
        inputId = "periodSelectDiversity",
        label = "Period",
        choices = period_options
      ))
```

:::

:::
</div>

<div class="context-icons">

<div class="context-icons-box" onclick="location.href='https://obis.org';">{{< fa download >}} DOWNLOAD THE FILE</div>

<div class="context-icons-box" onclick="location.href='https://obis.org';">{{< fa brands github >}} ACCESS THE CODE</div>

<div class="context-icons-box" onclick="location.href='https://obis.org';">{{< fa play >}} RUN THE MODEL</div>

</div>

:::



:::
:::

:::


<!-- HERE STARTS THE SECOND SECTION - GRAPHS, AND ETC -->
<div class="body-section">
::: {.grid}

<!-- Table 1 --->
::: {.g-col-md-6 .g-col-12}
`r tags$div(id="table1-title", class="body-title", textOutput("tableATitle"))`

```{r}
DT::dataTableOutput("tableA")
```

:::

<!-- Graphic 1 -->
::: {.g-col-md-6 .g-col-12}
`r tags$div(id="graph-title", class="body-title", textOutput("graphTitle"))`

```{r}
plotlyOutput("plotA")
```

:::

<!-- Table 2 --->
::: {.g-col-md-6 .g-col-12}
`r tags$div(id="table1-title", class="body-title", textOutput("tableBTitle"))`

```{r}
DT::dataTableOutput("tableB")
```

:::

<!-- Text 1 -->
::: {.g-col-md-6 .g-col-12}
`r tags$div(id="text-title", class="body-title", textOutput("textTitle"))`

`r tags$div(id="text-title", class="body-text", textOutput("textModel"))`
:::

:::
</div>

<!-- HERE STARTS THE METHODS SECTION -->
::: {.methods-div}

## How models were created?

Models were created using a point-process framework. Details on the modelling framework adopted by MPA Europe, including the full documentation are available [in this link.](https://iobis.github.io/mpaeu_docs/)

## How should I use this information?

Species Distribution Models (SDMs) provide valuable insights for both research and conservation efforts. These maps depict the relative and potential suitability of habitats for a particular species, aiding researchers and conservationists in understanding where a species could potentially occur. It is important to note that SDMs show suitability rather than presence, meaning the species may not actually occur throughout the entire extent indicated on the map. Additionally, there is inherent uncertainty associated with all SDM maps, stemming from various factors such as data quality, model assumptions, and environmental variability. Therefore, while SDMs offer valuable information, their results should be interpreted critically, considering the limitations and uncertainties associated with the models. 

:::

<!-- HERE STARTS THE FOOTER -->
<div id="footer-div" class="footer-div">

## MPA Europe project

Using a holistic range of measures that include the range of biodiversity from species to ecosystems, including habitats, areas will be prioritised using systematic conservation planning software. This enables alternative weighting of variables and multiple scenarios and thus support wider marine spatial planning.

::: {.grid}

::: {.g-col-md-3 .g-col-12 #footer-links}
### Explore more

[<span class="material-symbols-outlined" style="font-size: 12px; vertical-align: middle !important;">chevron_right</span>MPA Europe](https://mpa-europe.eu/)  
[<span class="material-symbols-outlined" style="font-size: 12px; vertical-align: middle !important;">chevron_right</span>OBIS](https://obis.org)

Product created by the [Ocean Biodiversity Information System](https://obis.org)

![](www/obis_logo.png){width=80%}
:::

::: {.g-col-md-9 .g-col-12 #footer-credits}
### Support

Grant Agreement 101059988 – MPA Europe | 
MPA Europe project has been approved under HORIZON-CL6-2021-BIODIV-01-12 — Improved science based maritime spatial planning and identification of marine protected areas.

Co-funded by the European Union. Views and opinions expressed are however those of the authors only and do not necessarily reflect those of the European Union or UK Research and Innovation. Neither the European Union nor the granting authority can be held responsible for them.

![](www/euuk_logo.png){width=50%}
:::

:::

<div style="font-size: 8px; color: white; text-align: center;">All data shown in this website is under a CC-0 licence.</div>

</div>

```{r}
#| context: server-start
#| include: false

# Load needed packages ----
library(leaflet)
library(leafem)
library(leafpm)
library(leaflet.extras2)
library(leaflet.providers)
# Add maps and content ----
library(dplyr)
library(terra)
library(plotly)
library(ggplot2)
library(stars)
# Source functions
source("functions.R")

# Settings ----
debug = F # Set here to TRUE to see debugging messages

# Create debug function
mdebug <- function(text, toprint = debug) {
  if (toprint) {
    message(text)
  }
  return(invisible(NULL))
}

# Create leaflet object ----
m <- leaflet() %>% 
  addTiles(group = "Open Street Maps", layerId = "baseid") %>%
  addProviderTiles(providers$CartoDB.Positron, group = "CartoDB") %>%
  addProviderTiles(providers$CartoDB.DarkMatter, group = "CartoDB Dark") %>%
  addLayersControl(
    overlayGroups = c("Points", "Native ecoregions"),
    baseGroups = c("Open Street Maps", "CartoDB", "CartoDB Dark"),
    options = layersControlOptions(collapsed = T),
    position = "bottomright"
  ) %>%
  addEasyprint(options = easyprintOptions(
    title = 'Print map',
    position = 'bottomleft',
    exportOnly = TRUE)) %>%
  setView(lng = 0.35, lat = 65, zoom = 3)

# Add title/text species
speciesinfo <- read.csv("data/all_splist_20231017.csv")
```

```{r}
#| context: server
# This is the code that is executed on the server

# TODO: 
# change selectInput for server-side selectize: https://shiny.posit.co/r/articles/build/selectize/
# improve code (clean up)


##### PART 1 - SPECIES ######

# Set reactive for the map ----
current_map <- reactiveVal()


# Start by ploting/printing placeholders ----
output$mainMap <- renderLeaflet({
  mdebug("Rendering Leaflet map")
  current_map()})

output$tableATitle <- renderText({ "Select a map to start" })


# Create species selectize ----
sp_options <- c("", "Phocoena phocoena")
updateSelectizeInput(session, "speciesSelect", choices = sp_options, server = TRUE)


# Tab actions ----
# Set first tab
active_tab <- reactiveValues()
active_tab$current <- "species"
  
# Observe tab changes
observeEvent(input$jsValue, {
  mdebug("New tab active")
  # If there is a new value:
  if (active_tab$current != input$jsValue$id) {
    # output$mainMap <- renderLeaflet({eval(parse(text = paste0("map_", 
    #                                                          input$jsValue$id)))})
    
    # Update current status
    active_tab$current <- input$jsValue$id
    
    # Temporary workaround while other features will be added!
    if (active_tab$current != "species") {
      shinyalert::shinyalert("Feature not available", "For now only species distribution maps are available.", type = "info")
      active_tab$current <- "species"
      session$sendCustomMessage("backToTab", "nothing")
    }
    #
  }
})

# Observe first input change
input_state <- reactiveValues(status = 0)
bindEvent(observe({input_state$status <- 1}), input$speciesSelect,
          once = TRUE, ignoreInit = TRUE)
bindEvent(observe({input_state$status <- 2}), input$speciesSelectThermal,
          once = TRUE, ignoreInit = TRUE)
# bindEvent(observe({input_state$status <- 3}), input$speciesSelect,
#           once = TRUE, ignoreInit = TRUE)
# bindEvent(observe({input_state$status <- 4}), input$speciesSelectThermal,
#           once = TRUE, ignoreInit = TRUE)

# Create a reactive for titles
title_state <- reactiveValues()
title_state$current <- "empty"

base_list <- list(
  tableA = "Select a map to start",
  graph = "",
  tableB = "",
  modelTitle = ""
)

observe({
  session$sendCustomMessage("showContext", "nothing")
}) %>%
  bindEvent(input$mainMap_draw_new_feature)

observe({
  if (title_state$current != active_tab$current) {
    session$sendCustomMessage("removeContext", "nothing")
    # Species condition
    if (active_tab$current == "species") {
      if (input$speciesSelect != "") {
        title_state$current <- "species"
        title_state$to_print <- list(
          tableA = "Model metrics",
          graph = "Response curves",
          tableB = "Variables importance",
          modelTitle = "Model explanation"
        )
      } else {
        title_state$to_print <- base_list
      }
    }
    
    # Thermal condition
    if (active_tab$current == "thermal") {
      if (input$speciesSelectThermal != "") {
        title_state$current <- "thermal"
        title_state$to_print <- list(
          tableA = "Area",
          graph = "Response curves thermal",
          tableB = "Variables importance",
          modelTitle = "Model explanation"
        )
      } else {
        title_state$to_print <- base_list
      }
    }
    
    # Habitat condition
    if (active_tab$current == "habitat") {
      if (input$speciesSelect != "") {
        title_state$current <- "species"
        title_state$to_print <- list(
          tableA = "Model metrics",
          graph = "Response curves",
          tableB = "Variables importance",
          modelTitle = "Model explanation"
        )
      } else {
        title_state$to_print <- base_list
      }
    }
    
    # Diversity condition
    if (active_tab$current == "diversity") {
      if (input$speciesSelect != "") {
        title_state$current <- "species"
        title_state$to_print <- list(
          tableA = "Model metrics",
          graph = "Response curves",
          tableB = "Variables importance",
          modelTitle = "Model explanation"
        )
      } else {
        title_state$to_print <- base_list
      }
    }
  }
}) %>%
  bindEvent(c(input_state$status, active_tab$current))



# Print titles ----
output$tableATitle <- renderText({title_state$to_print$tableA})
output$graphTitle <- renderText({title_state$to_print$graph})
output$tableBTitle <- renderText({title_state$to_print$tableB})
output$textTitle <- renderText({title_state$to_print$modelTitle})




## Species ----
# Title/context text
output$selectedSpecies <- renderText({
  input$speciesSelect
})

output$contextSpecies <- renderText({
  selinf <- speciesinfo[speciesinfo$species == input$speciesSelect,]
  if (input$speciesSelect != "") {
    spmodinfo <- jsonlite::read_json(glue::glue("data/maps/taxonid={selinf$key}/model=wwf/taxonid={selinf$key}_model=wwf_what=log.json"))
  } else {
    spmodinfo <- NULL
  }
  nrec <- unlist(spmodinfo$model_fit_points)
  neval <- unlist(spmodinfo$model_eval_points)
  tenvstat <- unlist(spmodinfo$model_posteval[["maxent"]]$thermal_envelope[[1]]$status)
  tenvstat <- ifelse(grepl("inside", tenvstat), "Yes", "No")
  tenvval <- unlist(spmodinfo$model_posteval[["maxent"]]$thermal_envelope[[1]]$percentage)
  glue::glue(
      "<b>Phylum:</b> {selinf$phylum} > <b>Order:</b> {selinf$order} > <b>Family:</b> {selinf$family} <br>
      <b>AphiaID:</b> <a style = 'text-decoration: none; color: #07A5F0;' target='_blank' href = 'https://www.marinespecies.org/aphia.php?p=taxdetails&id={selinf$key}'>{selinf$key}</a><br><br>
    <b>Number of records:</b> {nrec} <br>
    <b>Number of records for independent evaluation:</b> {neval} <br><br>
    <b>Additional info:</b> All inside thermal envelope? {tenvstat} ({tenvval}%)"
  )
})

speciespts <- reactive({
  spkey <- speciesinfo$key[speciesinfo$species == input$speciesSelect]
  pts <- arrow::read_parquet(paste0("data/maps/taxonid=", spkey, "/model=wwf/taxonid=", spkey, "_model=wwf_what=fitocc.parquet"))[,1:2]
  colnames(pts) <- c("longitude", "latitude")
  pts
})

maskstate <- reactiveVal(FALSE)
observe({
  maskstate(!maskstate())
}) %>% bindEvent(input$jsMask)

maskshape <- reactive({
    spkey <- speciesinfo$key[speciesinfo$species == input$speciesSelect]
    mask_layer <- terra::rast(paste0("data/maps/taxonid=", spkey, "/model=wwf/predictions/taxonid=", spkey, "_model=wwf_mask_cog.tif"))
    mask_layer <- mask_layer$native_ecoregions
    mask_layer <- as.polygons(mask_layer, values = T)
    mask_layer <- simplifyGeom(mask_layer)
    tfile <- tempfile(fileext = ".fgb")
    sf::st_write(sf::st_as_sf(mask_layer), tfile, append = F, quiet = T)
    tfile
})

files_inuse <- reactiveValues(file_a = NULL,
                              file_b = NULL)

# Change the MAP reactive
speciesmap <- reactive({
  
  sp_info <- list(
    species = input$speciesSelect,
    model = input$modelSelect,
    scenario = tolower(input$scenarioSelect),
    decade = ifelse(is.null(input$periodSelect), NULL,
                ifelse(input$periodSelect == 2050, "dec50", "dec100")),
    spkey = speciesinfo$key[speciesinfo$species == input$speciesSelect]
  )

  basepath <- paste0("data/maps/taxonid=", sp_info$spkey, "/model=wwf/predictions/")

  mdebug(paste("In use species", sp_info$species, sp_info$model, sp_info$scenario, collapse = ","))
  mdebug(paste0(basepath, "taxonid=", sp_info$spkey, "_model=wwf", "_method=", sp_info$model, "_scen=", sp_info$scenario, "_", sp_info$decade, "_cog.tif"))
  
  side_select <- input$sideSelect

  if (sp_info$scenario == "current") {
    file_a <- paste0(basepath, "taxonid=", sp_info$spkey, "_model=wwf", "_method=", sp_info$model, "_scen=current_cog.tif")
    file_b <- NULL
  } else {
    if (side_select) {
      file_a <- paste0(basepath, "taxonid=", sp_info$spkey, "_model=wwf", "_method=", sp_info$model, "_scen=current_cog.tif")
      file_b <- paste0(basepath, "taxonid=", sp_info$spkey, "_model=wwf", "_method=", sp_info$model, "_scen=", sp_info$scenario, "_", sp_info$decade, "_cog.tif")
    } else {
      file_a <- paste0(basepath, "taxonid=", sp_info$spkey, "_model=wwf", "_method=", sp_info$model, "_scen=", sp_info$scenario, "_", sp_info$decade, "_cog.tif")
      file_b <- NULL
    }
  }
  
  #Add mask if requested
  if (maskstate()) {
     mdebug("Mask active")

     # Load mask
     mask_layer <- terra::rast(paste0("data/maps/taxonid=", sp_info$spkey, "/model=wwf/predictions/taxonid=", sp_info$spkey, "_model=wwf_mask_cog.tif"))

     # Create temp files
     temp_f_a <- tempfile(fileext = ".tif")
     temp_f_b <- tempfile(fileext = ".tif")

     # mask and save
     writeRaster(terra::mask(terra::rast(file_a), crop(mask_layer$native_ecoregions, terra::rast(file_a))), temp_f_a, overwrite = T)
     file_a <- temp_f_a
     if (!is.null(file_b)) {
       writeRaster(terra::mask(terra::rast(file_b), crop(mask_layer$native_ecoregions, terra::rast(file_b))), temp_f_b, overwrite = T)
       file_b <- temp_f_b
     }

  } else {
     mdebug("Mask deactivated")
  }
  
  files_inuse$file_a <- file_a
  files_inuse$file_b <- file_b

  if (sp_info$species == "") {
    m %>%
      leafem::addFgb(file = "data/studyarea.fgb", fillColor = "#184e77", fill = T)
  } else {
      m <- m %>%
      addCircleMarkers(data = speciespts(),
                       clusterOptions = NULL,#markerClusterOptions(),
                       group = "Points",
                       weight = 2,
                       radius = 5,
                       opacity = 1,
                       fillOpacity = 0.1,
                       color = "black") %>% 
      hideGroup("Points") %>%
      leafem::addFgb(file = maskshape(),
              fillColor = "#57D8FF", fill = T, fillOpacity = 0.1, weigth = 0.2,
              color = "#57D8FF", group = "Native ecoregions") %>%
      hideGroup("Native ecoregions") %>%
      addEasyButton(easyButton(
         icon = "fa-eye", title = "Activate/deactivate native mask",
         onClick = JS('
          function(btn, map) {
            var new_state = {id: "newstate", nonce: Math.random()};
            Shiny.onInputChange("jsMask", new_state);
          }
        '))
      )
      
      if (maskstate()) {
        m <- m %>% 
            addControl(tags$div(HTML('<span style="font-weight: bold; color: #184e77;">Mask active</span>')),
                       position = "topright")
      }
    
    if (sp_info$scenario != "current" & side_select) {
      
      m %>%
        addMapPane("left", zIndex = 0) %>%
        addMapPane("right", zIndex = 0) %>%
        removeTiles("baseid") %>%
        removeLayersControl() %>%
        addTiles(group = "Open Street", layerId = "leftbaseid",
                 options = pathOptions(pane = "left")) %>%
        addGeotiff(file = file_a,
                     opacity = 1,
                     colorOptions = colorOptions(
                       palette = rev(c("#7d1500", "#da4325", "#eca24e", "#e7e2bc", "#5cc3af", "#0a6265")),
                       domain = c(0, 100),
                       na.color = NA
                     ),
                     options = pathOptions(pane = "left"), autozoom = F) %>%
        addTiles(group = "Open Street B", layerId = "rightbaseid",
                 options = pathOptions(pane = "right")) %>%
        addGeotiff(file = file_b,
                     opacity = 1,
                     colorOptions = colorOptions(
                       palette = rev(c("#7d1500", "#da4325", "#eca24e", "#e7e2bc", "#5cc3af", "#0a6265")),
                       domain = c(0, 100),
                       na.color = NA
                     ),
                     options = pathOptions(pane = "right"), autozoom = F) %>%
        addSidebyside(layerId = "sidecontrols",
                      rightId = "rightbaseid",
                      leftId = "leftbaseid")

    } else {
      
      m %>%
        addGeotiff(file = file_a,
                     opacity = 1,
                     colorOptions = colorOptions(
                       palette = rev(c("#7d1500", "#da4325", "#eca24e", "#e7e2bc", "#5cc3af", "#0a6265")),
                       domain = c(0, 100),
                       na.color = NA
                     ), autozoom = F) %>%
        addPmToolbar(
          toolbarOptions = pmToolbarOptions(drawMarker = FALSE,
                                            drawPolyline = FALSE,
                                            drawCircle = FALSE,
                                            cutPolygon = FALSE,
                                            position = "topleft"),
          drawOptions = pmDrawOptions(snappable = FALSE, allowSelfIntersection = FALSE),
          editOptions = pmEditOptions(preventMarkerRemoval = FALSE, draggable = TRUE)
        )
    }
  }
  
  
  
})

# Set the new rendered map
observe({
  mdebug("Setting new map")
  current_map(speciesmap())
}) %>%
  bindEvent(speciesmap())



# Thermal
output$selectedSpeciesThermal <- renderText({
  input$speciesSelectThermal
}) %>%
  bindEvent(input$speciesSelectThermal, ignoreInit = T)


# # Create reactives for species/tab info
# react_species <- reactiveValues(status = 0)
# react_thermal <- reactiveValues(status = 0)
# react_habitat <- reactiveValues(status = 0)
# react_diversity <- reactiveValues(status = 0)
# 
# observe({
#   react_species$plot_raster <- rast("data/maps/species/key=100803/mv1_pr/lasso_naive/predictions/mv1_pr_lasso_naive_key100803_basevars_current.tif")
#   react_species$status <- react_species$status + 1
# }) %>%
#   bindEvent(input$speciesSelect, ignoreInit = TRUE)

# TODO: add habitat and diversity

 # context_leaf_info <- reactiveValues(haveinfo = FALSE)
  
  
  
## Contextual info ----
continfo <- reactiveValues()

observe({
  
  if (active_tab$current == "species") {
    
    spkey <- speciesinfo$key[speciesinfo$species == input$speciesSelect]
    
    basepath <- paste0("data/maps/taxonid=", spkey, "/model=wwf/metrics/")
    
    # Table 1
    metrics <- arrow::read_parquet(
      paste0(basepath, "taxonid=", spkey, "_model=wwf_method=", input$modelSelect, "_what=cvmetrics.parquet")
    )
    metrics_mean <- metrics %>%
      summarise(across(1:ncol(metrics), function(x) {round(mean(x), 2)}))
    metrics_mean <- metrics_mean %>%
      tidyr::pivot_longer(cols = 1:ncol(metrics_mean), names_to = "Metric", values_to = "Mean of 5 folds") %>%
      mutate(Metric = toupper(Metric))
    metrics_sd <- metrics %>%
      summarise(across(1:ncol(metrics), function(x) {round(sd(x), 2)}))
    metrics_sd <- metrics_sd %>%
      tidyr::pivot_longer(cols = 1:ncol(metrics_sd), names_to = "Metric", values_to = "SD") %>%
      mutate(Metric = toupper(Metric))
    metrics_mean <- left_join(metrics_mean, metrics_sd, by = "Metric")
    # metrics_mean <- metrics_mean %>%
    #   filter(Metric %in% c("AUC", "CBI", "PR", "TSS_P10"))
    continfo$tableA <- metrics_mean
    
    # Graph
    response_curves <- arrow::read_parquet(
      paste0(basepath, "taxonid=", spkey, "_model=wwf_method=", input$modelSelect, "_what=respcurves.parquet")
    )
    # response_curves <- response_curves %>%
    #   group_by(variable) %>%
    #   mutate(base = scale(base))
    # pa <- ggplot(response_curves) +
    #   geom_line(aes(x = base, y = response, color = variable)) +
    #   theme_light() +
    #   xlab("Value (scaled)") + ylab("Response")
    
    continfo$plotA <- gen_plotly_resp(response_curves)
    
    # Text
    continfo$text[[1]] <- paste("Model explanation -",
                                switch(strtrim(input$modelSelect, 3),
                                       brt = "BRT",
                                       las = "LASSO",
                                       ela = "elasticnet",
                                       max = "MAXENT",
                                       rf_ = "Random Forest",
                                       glm = "GLM",
                                       gam = "GAM",
                                       xgb = "XGBoost",
                                       lgb = "LightGBM",
                                       ens = "Ensemble"))
    
    context_file <- jsonlite::read_json("context_info.json")
    continfo$text[[2]] <- switch(strtrim(input$modelSelect, 3),
       brt = unlist(context_file$models[["brt"]]),
       las = unlist(context_file$models[["lasso"]]),
       ela = unlist(context_file$models[["elasticnet"]]),
       max = unlist(context_file$models[["maxent"]]),
       rf_ = unlist(context_file$models[["rf"]]),
       glm = unlist(context_file$models[["glm"]]),
       gam = unlist(context_file$models[["gam"]]),
       xgb = unlist(context_file$models[["xgboost"]]),
       lgb = unlist(context_file$models[["lightgbm"]]),
       ens = unlist(context_file$models[["ensemble"]]))
    
  }
  
}) %>%
  bindEvent(c(input$speciesSelect, input$modelSelect), ignoreInit = TRUE)

output$tableA <- DT::renderDT({
  #continfo$tableA
   DT::datatable(continfo$tableA, options = list(paging =TRUE, pageLength = 5))
}) %>%
  bindEvent(continfo$tableA)

output$plotA <- renderPlotly({
  continfo$plotA
}) %>%
  bindEvent(continfo$plotA)

output$tableB <- DT::renderDT({
  DT::datatable(continfo$tableA, options = list(paging =TRUE, pageLength = 5))
}) %>%
  bindEvent(continfo$tableA)

output$textTitle <- renderText({
  continfo$text[[1]]
}) %>%
  bindEvent(continfo$text)

output$textModel <- renderText({
  continfo$text[[2]]
}) %>%
  bindEvent(continfo$text)

### Drawing context info ----
continfo_leaf <- reactiveValues()

observe({
  
  coords <- lapply(input$mainMap_draw_new_feature$geometry$coordinates[[1]], function(x){
    paste(x, collapse = " ")
  })
  
  wkt <- paste("POLYGON ((", paste(coords, collapse = ","),"))")
  
  vect_obj <- terra::vect(wkt)
  
  terra::crs(vect_obj) <- "EPSG:4326"
  
  if (active_tab$current == "species") {
    mdebug(paste("Active tab for data extraction:", active_tab$current))
    
    sp_info <- list(
        species = input$speciesSelect,
        model = input$modelSelect,
        scenario = tolower(input$scenarioSelect),
        decade = ifelse(is.null(input$periodSelect), NULL,
                    ifelse(input$periodSelect == 2050, "dec50", "dec100")),
        spkey = speciesinfo$key[speciesinfo$species == input$speciesSelect]
    )

    vals <- terra::extract(terra::rast(files_inuse$file_a), vect_obj)
    vals <- vals[,2]
    vals <- vals[!is.na(vals)]
    
    if (any(is.null(vals)) | any(is.na(vals))) {
      vals <- 0
    }
    
    p <- ggplot(data.frame(ROR = vals)) +
      geom_density(aes(x = ROR), fill = "#1a759f", color = NA) +
      xlab("Relative Occurrence Rate") +
      ylab(NULL) +
      theme_classic() +
      theme(axis.line.x = element_blank(),
            axis.line.y = element_blank(),
            axis.ticks.y = element_blank(),
            axis.text.y = element_blank())
    
    continfo_leaf$density <- p
    
    continfo_leaf$text <- glue::glue(
      "<span style='font-size:larger;'><b>Selected area</b></span> <br> 
    <b>Mean Relative Occurrence Rate:</b> {round(mean(vals), 2)} <br>
    <b>Standard deviation ROR:</b> {round(sd(vals), 2)} <br>
    <b>Total area:</b> {round(terra::expanse(vect_obj, unit = 'km'), 2)}km² <br><br>"
    )
  }
  
  
}) %>%
  bindEvent(input$mainMap_draw_new_feature)

output$contextMap <- renderPlot({
  continfo_leaf$density
}, height = 200, width = 200) %>%
  bindEvent(continfo_leaf$density)

output$contextMapText <- renderText({
  continfo_leaf$text
}) %>%
  bindEvent(continfo_leaf$text)
  
outputOptions(output, "contextMap", suspendWhenHidden = FALSE)



# Add mask to map ----
# observe({
#   mdebug("Mascara ativa")
#   print(input$jsMask)
#   leafletProxy("mainMap") %>%
#     removeTiles("baseid")
# }) %>%
#   bindEvent(input$jsMask)
```
